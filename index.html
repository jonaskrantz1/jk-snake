<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Jonas Snakespel</title>
  <link rel="stylesheet" href="https://pyscript.net/releases/2025.3.1/core.css" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <link rel="icon" href="favicon.png" type="image/png">
  <script type="module" src="https://pyscript.net/releases/2025.3.1/core.js"></script>
  <style>
    body {
      background-color: #000;
      text-align: center;
      color: white;
      font-family: 'Press Start 2P', Arial, sans-serif;
      margin: 0; padding: 0;
    }
    canvas {
      background-color: #222;
      border: 1px solid white;
      margin-top: 20px;
      width: 100%; max-width: 600px; height: auto;
    }
    #startScreen {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      z-index: 10;
    }
    #startButton {
      font-size: 24px; padding: 10px 20px; margin-bottom: 20px;
    }
    #topList { font-size: 18px; margin-top: 10px; text-align: left; }
    #touchControls { margin-top: 20px; }
    #touchControls button {
      font-size: 32px; padding: 10px 20px; margin: 5px;
    }
    @media (hover: hover) { #touchControls { display: none; } }
  </style>
</head>
<body>
  <h1>Jonas snakespel</h1>

  <div id="startScreen">
    <button id="startButton" onclick="startWithMusic()">Klicka fÃ¶r att starta spelet</button>
    <div id="topList">HÃ¤mtar global highscoreâ€¦</div>
  </div>

  <canvas id="gameCanvas" width="600" height="400"></canvas>

  <div id="touchControls">
    <button id="btnUp">â¬†ï¸</button><br>
    <button id="btnLeft">â¬…ï¸</button>
    <button id="btnDown">â¬‡ï¸</button>
    <button id="btnRight">â¡ï¸</button>
  </div>

  <audio id="soundFood" src="pling.wav"></audio>
  <audio id="soundDeath" src="death.wav"></audio>
  <audio id="bgMusic" src="music.mp3" loop></audio>

  <py-script>
import asyncio, random, time, json
from js import document, window, fetch
from pyodide.ffi import create_proxy, to_js

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 1) Custom-start-event
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def _on_start(evt):
    start_game()
document.addEventListener("startGame", create_proxy(_on_start))

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 2) Globala variabler
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
WIDTH, HEIGHT, CELL = 600, 400, 20
canvas = document.getElementById("gameCanvas")
ctx = canvas.getContext("2d")
game_state = "waiting"

player_snake = [(WIDTH//2, HEIGHT//2)]
player_length = 2
player_score = 0

enemy_snake = [(300, 200)]
enemy_length = 2

foods = [(random.randrange(0, WIDTH, CELL),
          random.randrange(0, HEIGHT, CELL),
          "red") for _ in range(2)]
direction = (CELL, 0)
highscores = []
MAX_HIGHSCORES = 20
level = 1
counter = 0

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 3) Timerâ€mekanism
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
time_left = 20.0          # start pÃ¥ 20 sek
speed_delay = 0.1         # ursprungsâ€delay
speed_multiplier = 0.85   # 15% snabbare vid varje 20â€sekâ€intervall
rainbow_exists = False    # regnbÃ¥gskakan

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 4) Mobilstyrning
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def touch_direction(dir):
    global direction
    if game_state != "playing": return
    if dir=="up"    and direction[1]==0: direction=(0,-CELL)
    if dir=="down"  and direction[1]==0: direction=(0,CELL)
    if dir=="left"  and direction[0]==0: direction=(-CELL,0)
    if dir=="right" and direction[0]==0: direction=(CELL,0)

for btn, d in [("btnUp","up"),("btnDown","down"),("btnLeft","left"),("btnRight","right")]:
    document.getElementById(btn).addEventListener(
        "click", create_proxy(lambda e,dir=d: touch_direction(dir))
    )

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 5) Highscoreâ€API
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
async def submit_highscore(name, score):
    url="https://highscore.jonas-krantz-1.workers.dev/highscores"
    data=json.dumps({"name":name,"score":score})
    resp=await fetch(url, to_js({
        "method":"POST",
        "headers":{"Content-Type":"application/json"},
        "body":data
    }))
    return (await resp.json()).to_py()

async def get_highscores():
    resp=await fetch("https://highscore.jonas-krantz-1.workers.dev/highscores")
    return (await resp.json()).to_py()

async def update_start_toplist():
    global highscores
    try:
        hs = await get_highscores()
        highscores = hs
        html = "<h3>Global Topplista:</h3><ol>"
        for i, entry in enumerate(hs[:MAX_HIGHSCORES], start=1):
            html += f"<li>{entry['name']}: {entry['score']}</li>"
        html += "</ol>"
        document.getElementById("topList").innerHTML = html
    except Exception as e:
        document.getElementById("topList").innerHTML = f"<p>Fel: {e}</p>"

async def check_highscore():
    global highscores, player_score
    hs = await get_highscores()
    # kvalificerar sig om mindre Ã¤n 20 eller hÃ¶gre Ã¤n den lÃ¤gsta av topp 20
    qualifies = len(hs) < MAX_HIGHSCORES or player_score > min(e["score"] for e in hs[:MAX_HIGHSCORES])
    if not qualifies:
        highscores = hs
        return
    name = window.prompt("NY HIGH SCORE! Namn:") or "Anon"
    highscores = await submit_highscore(name, player_score)
    await update_start_toplist()

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 6) Gameâ€over & start
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def stop_music():
    try: document.getElementById("bgMusic").pause()
    except: pass

async def game_over():
    global game_state
    stop_music()
    try: document.getElementById("soundDeath").play()
    except: pass
    game_state="gameover"
    await asyncio.sleep(0.1)
    await check_highscore()
    document.getElementById("startScreen").style.display="flex"

def start_game(evt=None):
    global game_state, counter, player_score, player_length
    global player_snake, enemy_snake, enemy_length, foods, direction
    global time_left, speed_delay, level
    game_state="playing"
    counter=0
    player_snake[:] = [(WIDTH//2,HEIGHT//2)]
    player_length=5; player_score=0
    enemy_snake[:] = [(300,200)]; enemy_length=1
    foods[:] = [(random.randrange(0,WIDTH,CELL),
                 random.randrange(0,HEIGHT,CELL),"red") for _ in range(2)]
    direction=(CELL,0)
    time_left = 20.0      # Ã¥terstÃ¤ll till 20 sek
    speed_delay = 0.1     # Ã¥terstÃ¤ll ursprungsfart
    level = 1             # Ã¥terstÃ¤ll level 
    document.getElementById("startScreen").style.display="none"
    try: document.getElementById("bgMusic").play()
    except: pass
    for id in ("soundFood","soundDeath"):
        el=document.getElementById(id)
        if el: el.load()

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 7) Ritaâ€funktioner (ofÃ¶rÃ¤ndrade)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def draw_game_over():
    ctx.fillStyle="black"; ctx.fillRect(0,0,WIDTH,HEIGHT)
    ctx.fillStyle="red"; ctx.font="16px 'Press Start 2P'"
    ctx.fillText("GAME OVER",WIDTH//2-120,HEIGHT//2-40)
    ctx.fillStyle="white"; ctx.font="12px 'Press Start 2P'"
    ctx.fillText(f"PoÃ¤ng: {player_score}",WIDTH//2-80,HEIGHT//2)
    ctx.fillText("Tryck pÃ¥ start",WIDTH//2-100,HEIGHT//2+40)
    ctx.fillText("fÃ¶r att spela igen",WIDTH//2-130,HEIGHT//2+60)
    draw_ui()

def draw_snake():
    for x,y in player_snake:
        ctx.fillStyle="lime"; ctx.fillRect(x,y,CELL,CELL)

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 3) Rita regnbÃ¥gsâ€mat med blinkande fÃ¤rg i draw_food()
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def draw_food():
    for x, y, kind in foods:
        if kind == "rainbow":
            # vÃ¤xlande hue
            hue = int((time.time() * 200) % 360)
            ctx.fillStyle = f"hsl({hue},100%,50%)"
        elif kind == "yellow":
            ctx.fillStyle = "gold"
        else:
            ctx.fillStyle = "red"
        ctx.fillRect(x, y, CELL, CELL)

def draw_enemy():
    for x,y in enemy_snake:
        ctx.fillStyle="blue"; ctx.fillRect(x,y,CELL,CELL)

def draw_ui():
    ctx.fillStyle = "white"; ctx.font = "16px Arial"
    ctx.fillText(f"PoÃ¤ng: {player_score}", 10, 20)
    ctx.fillText(f"Tid: {int(time_left)}", WIDTH-100, 20)
    ctx.fillText(f"Level: {level}", 10, 40)

    if game_state == "gameover":
        y = 100
        ctx.fillText("Topplista:", 10, y)
        for i, entry in enumerate(highscores[:MAX_HIGHSCORES], start=1):
            y += 20
            ctx.fillText(f"{i}. {entry['name']}: {entry['score']}", 10, y)

def update_snake():
    global player_snake, player_score, player_length, rainbow_exists
    head_x, head_y = player_snake[0]
    dx, dy = direction
    new_head = ((head_x + dx) % WIDTH, (head_y + dy) % HEIGHT)

    # selfâ€krock etc...
    if new_head in player_snake or new_head in enemy_snake:
        asyncio.ensure_future(game_over())
        return

    player_snake.insert(0, new_head)

    # rainbow fÃ¶rst
    for f in foods[:]:
        if (f[0], f[1]) == new_head and f[2] == "rainbow":
             player_length = max(1, player_length // 2)
             # TRIMMA kroppen sÃ¥ att lÃ¤ngden verkligen halveras
             player_snake[:] = player_snake[:player_length]
            foods.remove(f)
            rainbow_exists = False
            return

    # gul/rÃ¶d som tidigare
    for f in foods[:]:
        if (f[0], f[1]) == new_head:
            player_length += 1
            player_score += 10 if f[2] == "red" else 30
            try: document.getElementById("soundFood").play()
            except: pass
            foods.remove(f)
            if f[2] == "red":
                foods.append((random.randrange(0, WIDTH, CELL),
                              random.randrange(0, HEIGHT, CELL),
                              "red"))
            return

    if len(player_snake) > player_length:
        player_snake.pop()

def get_valid_enemy_move(head):
    body_except_tail = enemy_snake[:-1]
    def safe(pos):
        return pos not in body_except_tail and pos not in player_snake

    # Prioritetsordning: rainbow â†’ yellow â†’ nÃ¤rmaste red
    rainbow = [f for f in foods if f[2] == "rainbow"]
    yellow  = [f for f in foods if f[2] == "yellow"]
    if rainbow:
        tx, ty = rainbow[0][:2]
    elif yellow:
        tx, ty = yellow[0][:2]
    else:
        reds = [f for f in foods if f[2] == "red"]
        reds.sort(key=lambda f: abs(f[0] - head[0]) + abs(f[1] - head[1]))
        tx, ty = (reds[0][0], reds[0][1]) if reds else (None, None)

    directions = [(CELL, 0), (-CELL, 0), (0, CELL), (0, -CELL)]
    if tx is not None:
        directions.sort(key=lambda d: abs(((head[0]+d[0])%WIDTH) - tx) + abs(((head[1]+d[1])%HEIGHT) - ty))

    for dx, dy in directions:
        np = ((head[0]+dx)%WIDTH, (head[1]+dy)%HEIGHT)
        if safe(np):
            return dx, dy

    return directions[0]


def update_enemy():
    global enemy_snake, enemy_length, rainbow_exists

    head = enemy_snake[0]
    dx, dy = get_valid_enemy_move(head)
    new_head = ((head[0] + dx) % WIDTH, (head[1] + dy) % HEIGHT)

    if new_head in enemy_snake or new_head in player_snake:
        enemy_snake[:] = [(300, 200)]
        enemy_length = 1
        rainbow_exists = False
        return

    enemy_snake.insert(0, new_head)

    # 1) rainbowâ€mat
    for f in foods[:]:
        if (f[0], f[1]) == new_head and f[2] == "rainbow":
            enemy_length = max(1, enemy_length // 2)
            # TRIMMA fiendekroppen ocksÃ¥
            enemy_snake[:] = enemy_snake[:enemy_length]
            foods.remove(f)
            rainbow_exists = False
            return

    # 2) gul
    for f in foods[:]:
        if (f[0], f[1]) == new_head and f[2] == "yellow":
            enemy_length += 1
            foods.remove(f)
            foods.append((random.randrange(0, WIDTH, CELL),
                          random.randrange(0, HEIGHT, CELL),
                          "yellow"))
            return

    # 3) rÃ¶d
    for f in foods[:]:
        if (f[0], f[1]) == new_head and f[2] == "red":
            enemy_length += 1
            foods.remove(f)
            foods.append((random.randrange(0, WIDTH, CELL),
                          random.randrange(0, HEIGHT, CELL),
                          "red"))
            return

    # 4) tailâ€pop
    if len(enemy_snake) > enemy_length:
        enemy_snake.pop()

def key_handler(e):
    global direction
    k=e.key
    if game_state!="playing": return
    if k=="ArrowUp" and direction[1]==0: direction=(0,-CELL)
    if k=="ArrowDown" and direction[1]==0: direction=(0,CELL)
    if k=="ArrowLeft" and direction[0]==0: direction=(-CELL,0)
    if k=="ArrowRight" and direction[0]==0: direction=(CELL,0)

document.addEventListener("keydown", create_proxy(key_handler))

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 8) Evig loop + nedrÃ¤kning
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
async def game_loop():
    global counter, time_left, speed_delay, level, rainbow_exists

    while True:
        if game_state == "playing":
            # nedrÃ¤kning
            time_left -= speed_delay
            if time_left <= 0:
                speed_delay *= speed_multiplier
                time_left = 20.0
                level += 1
                # Var tredje level: spawn rainbow om ingen finns
                if level % 3 == 0 and not rainbow_exists:
                    foods.append((
                        random.randrange(0, WIDTH, CELL),
                        random.randrange(0, HEIGHT, CELL),
                        "rainbow"
                    ))
                    rainbow_exists = True

            # rita spel
            ctx.fillStyle = "black"; ctx.fillRect(0, 0, WIDTH, HEIGHT)
            update_snake(); draw_snake(); draw_food(); draw_enemy(); draw_ui()
            if counter % 2 == 0:
                update_enemy()
            # normal gul/rÃ¶dâ€spawn
            if not any(f[2] == "yellow" for f in foods) and random.random() < 0.01:
                foods.append((random.randrange(0, WIDTH, CELL),
                              random.randrange(0, HEIGHT, CELL),
                              "yellow"))
            counter += 1

        await asyncio.sleep(speed_delay)

asyncio.ensure_future(update_start_toplist())
asyncio.ensure_future(game_loop())
  </py-script>

  <script>
  async function startWithMusic(){
    let music=document.getElementById("bgMusic");
    if(music&&music.paused){
      try{await music.play()}catch(e){console.log("ğŸµ",e)}
    }
    document.dispatchEvent(new Event("startGame"));
  }
  </script>
</body>
</html>
